---
title: python相关备忘
published: 2025-10-16
description: '无关语法'
image: ''
tags: [python]
category: '备忘'
draft: false 
lang: ''
---
[官网](https://www.python.org/)
# 备忘
```python
#调包的路径，字符数组形式可以自己加路径
sys.path
#查看当前命名空间的所有名称
dir()
```
## 特殊变量
一个普通模块的特殊变量
| 特殊变量 | 描述 | 常见用途 |
|---------|------|----------|
| `__annotations__` | 类型注解字典 | 类型检查、文档生成 |
| `__builtins__` | 内置函数模块 | 访问Python内置功能 |
| `__cached__` | 字节码缓存路径 | 性能优化、调试 |
| `__doc__` | 模块文档字符串 | 帮助文档、自动生成文档 |
| `__file__` | 模块文件路径 | 路径处理、资源加载 |
| `__loader__` | 模块加载器 | 高级导入机制 |
| `__name__` | 模块名称 | 条件执行、调试 |
| `__package__` | 包名称 | 相对导入、包管理 |
| `__spec__` | 模块规范 | 元编程、插件系统 |
如果是包的话多一个`__all__`变量

## 命名空间

### 1. 四种命名空间
- **内置**：Python 自带函数 (`len`, `print` 等)
- **全局**：模块级别的变量和函数
- **闭包**：嵌套函数的外部函数变量  
- **局部**：函数内部的变量

### 2. 查找顺序（LEGB规则）
```python
name = "全局"  # Global

def outer():
    name = "闭包"  # Enclosing
    
    def inner():
        name = "局部"  # Local
        print(name)    # 输出: "局部"
    
    inner()

# 查找顺序: Local → Enclosing → Global → Built-in
```

### 3. 关键语法
```python
# 修改全局变量
count = 0
def increment():
    global count  # 声明使用全局变量
    count += 1

# 修改闭包变量  
def outer():
    num = 0
    def inner():
        nonlocal num  # 声明使用闭包变量
        num += 1
```

### 4. 查看命名空间
```python
print(globals())  # 查看全局命名空间
print(locals())   # 查看局部命名空间
```

### 5. 导入与命名空间
```python
import math           # 安全: math.sqrt()
from math import sqrt # 明确: sqrt()
from math import *    # 危险: 污染命名空间
```

**核心要点**：命名空间就像"变量住址"，决定了在哪里能找到变量，避免命名冲突。

# python自带的虚拟环境
## 创建虚拟环境
```bash
python -m venv <环境名称> #主流使用.venv
```
他会在你的当前目录下创建一个对应名称的文件夹环境存在的地方
## 激活虚拟环境
```bash
# Windows
<环境名称>\Scripts\activate
# macOS/Linux
source <环境名称>/bin/activate
```
## 退出虚拟环境
```bash
deactivate
```
# 项目管理
项目结构
```txt
project/
├── package1/
│   ├── __init__.py
│   ├── module2.py
│   └── module3.py
├── package2/
│   ├── __init__.py
│   ├── package1/
│   │   ├── __init__.py 
│   │   └── moudle4.py
│   └── module5.py
├── module1.py
└── main.py
```
## 模块
模块是一个python文件，里面可以含有`函数`，`常量`，`变量`，`类`，`主函数`。
比如
```python
# 1. 模块的文档字符串
"""
module1

这个模块提供了什么功能
作者
时间等元数据
"""
# 2. 变量 (Variables)
a=1

# 3. 常量 (Constants) - Python中没有真正的常量，但约定大写表示常量
PI =3.14

# 4. 函数 (Functions)
def add(a,b):
    return a+b

# 5. 类 (Classes)
class Student:
    
    def __init__(self, name=None, age=None):
        self._name = name
        self._age = age
    @property#相当于get方法
    def age(self):
        return self._age
    
    @age.setter#set方法
    def age(self, value):
        self._age = value

# 6.模块的主函数
import sys
print(f"__name__ = {__name__}")
#如果是直接运行这个模块的话，__name__就是__main__，
#如果是被调用的话，__name__是这个模块的名字。
print(__doc__)#打印这个模块的文档字符串
```
## 包
包是包含多个模块的目录，包含`__init__.py`文件。
`Python 3.3` 引入了“隐式命名空间包”， `__init__.py` 不再是必须的。
但是用`__init__.py`，你就可以`import <包名>`来直接调用你在init文件中导入的模块了。
```python
#package1/__init__.py
#显示表示这个包里有什么模块,这两个模块会放在package1的命名空间中
from . import module2
from . import module3
#init文件里可以写当这个包被调用时的函数，多次import这个包不会重复执行init文件里的主函数
print("package1初始化文件被执行")
#当然也能写包的函数，变量，常量，会进入到包的命名空间
def add(a,b):
    return a+b
#如果__init__.py里的命名和模块名重了，那么保留__init__.py里自带的，上面导入的模块将无法使用
def module2(a,b):#p1.module2将不会指定到module2模块，而是这个函数
    return a+b

from .module2 import add，PI

# 控制主函数 from package import * 引入的东西
__all__ = ['add']#只引的进add
```


## 导入方式
```python
#main.py
#导入整个模块，主函数命名空间dir()只有module1（模块名）被占用
import module1
a=module1.a
# 从模块导入特定内容,主函数命名空间dir(),只有被import的命名会被占用，如果是*的话会把所有的module里的命令引入过来
from module1 import a, add
a=add(1,2)
#如果使用了as那就只会把as后的名称进入命名空间
import numpy as np
#不能使用numpy只能用np
import package1.module2#package1被导入到主函数命名空间，module1被导入package1的命名空间，即使没用__init__.py也行
#会被包的__all__控制
from package1 import *
```
# 包管理
## pip
```bash
pip list
# 生成环境库的列表
pip freeze > requirements.txt
#把requirements.txt里的依赖全安装下来
pip install -r requirements.txt
```
但是requirements.txt混合了所有直接和间接依赖，
所以现代配置依赖以及管理项目元数据使用**pyproject.toml**。
```toml
[project]
name = "simple-project"
version = "0.1.0"
description = "一个简单的Python项目"
authors = [{name = "Your Name"}]
dependencies = [
    "requests>=2.25.0",
    "click>=8.0.0",
    ]
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"
```
使用pip安装.toml文件中的所有依赖
```bash
pip install -e .
#-e代表编辑模式可以把自己的项目作为一个依赖放在依赖路径中，调用时可以当正常依赖调用
```
## [uv](https://docs.astral.sh/uv/)
```bash
#列出所有可用的python版本,freetreaded实验版本不要用。
uv python list
#可以直接py脚本可以是python本身，进入对应版本的python解释器。如果没装过你指定的那个版本就会自动给你安装
#后面-p <python版本>可以不写，toml文件中指定了版本，他就会自动调用那个版本
#运行时自动进入该项目的虚拟环境
uv run -p <python版本> <py脚本>
#初始化一个标准python项目
uv init -p <python版本>
#自动帮你修改toml文件
uv add <python库>
#列出所有的依赖关系
uv tree
#工具将安装到全局
uv tool install <工具名>
uv tool list
#根据当前项目的toml文件自动下载全部依赖
nv sync
```
## 教学视频
<iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1YweNe2EGa&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
包管理
<iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV13WGHz8EEz&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
打包
<iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV12NgLzhEKx&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

## 常用的库
- [opencv](https://opencv.org/)
- [matplotlib](https://matplotlib.org/)
- [numpy](https://numpy.org/)
- os
- subprocess
- [pynput](https://pypi.org/project/pynput/)
- [flask](https://flask.palletsprojects.com/en/stable/)
- [django](https://www.djangoproject.com/)
- [fastapi](https://fastapi.tiangolo.com/)
- [ruff](https://docs.astral.sh/ruff/)
- [BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/)