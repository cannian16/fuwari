---
title: Linux 
published: 2025-12-12
description: 'linux备忘'
image: ''
tags: ['部署']
category: '备忘'
draft: false
lang: ''
---
# 权限管理
## 命令
```bash
chmod <权限数> <文件路径>
```
## 基本权限数字
- 4 = 读 (Read) = `r`
- 2 = 写 (Write) = `w`
- 1 = 执行 (Execute) = `x`

## 权限组合运算
```bash
# 举例：
rwx = 4+2+1 = 7    # 读写执行
rw- = 4+2+0 = 6    # 读写
r-x = 4+0+1 = 5    # 读执行
r-- = 4+0+0 = 4    # 只读
-wx = 0+2+1 = 3    # 写执行
-w- = 0+2+0 = 2    # 只写
--x = 0+0+1 = 1    # 只执行
--- = 0+0+0 = 0    # 无权限
```

## 三位数权限表示
`chmod` 命令中的三位数字分别代表：
```
用户(owner)   组(group)   其他用户(other)
    ↓            ↓            ↓
   abc
```

例如：
```bash
chmod 765 file.txt
# 7(4+2+1)=rwx 所有者：读写执行
# 6(4+2+0)=rw- 组用户：读写  
# 5(4+0+1)=r-x 其他用户：读执行
ls -l
#可以查出文件权限，比如这个就是644
-rw-r--r-- 1 root root 3444 Jul  6  2023 <文件名>
```


# Systemd 服务管理
`服务文件路径`：/etc/systemd/system/
## CLI
### 1. `sudo systemctl daemon-reload`
**作用**：重新加载 systemd 服务配置文件
**使用时机**：当你修改了 `.service` 文件后必须执行
```bash
# 比如你修改了 /etc/systemd/system/flaskapp.service
sudo nano /etc/systemd/system/flaskapp.service
sudo systemctl daemon-reload  # 让 systemd 知道配置变了
```

### 2. `sudo systemctl enable <服务名>`
**作用**：启用服务，让它在系统启动时自动运行
```bash
# 启用服务（开机自启）
sudo systemctl enable <服务名>

# 禁用服务（不开机自启）
sudo systemctl disable <服务名>
```

### 3. `sudo systemctl start <服务名>`
**作用**：立即启动服务
```bash
# 启动服务
sudo systemctl start <服务名>

# 停止服务
sudo systemctl stop <服务名>

# 重启服务
sudo systemctl restart <服务名>
```

### 4. `sudo systemctl status <服务名>`
**作用**：查看服务的运行状态和日志
```bash
# 查看状态
sudo systemctl status <服务名>

# 查看详细日志
sudo journalctl -u <服务名> -f
```

### 第一次设置服务时：
```bash
# 1. 创建服务文件
sudo vim /etc/systemd/system/flaskapp.service

# 2. 重新加载配置（让 systemd 认识新服务）
sudo systemctl daemon-reload

# 3. 启用服务（开机自启）
sudo systemctl enable flaskapp

# 4. 启动服务
sudo systemctl start flaskapp

# 5. 检查状态
sudo systemctl status flaskapp
```

### 日常管理：
```bash
# 查看状态
sudo systemctl status flaskapp

# 重启服务（部署新代码后）
sudo systemctl restart flaskapp

# 停止服务
sudo systemctl stop flaskapp

# 查看日志
sudo journalctl -u flaskapp -f
```

## 服务配置文件
```ini
# /etc/systemd/system/flaskapp.service
[Unit]
Description=Flask Backend Application
After=network.target #依赖关系，在网络服务启动之后启动服务

[Service]
Type=simple
User=root #执行用户
WorkingDirectory=/root/flask_backend
Environment=PATH=/root/flask_backend/.venv/bin
ExecStart=gunicorn -w 2 -b 0.0.0.0:5000 "flaskr:create_app()" #执行指令
Restart=always

[Install]
WantedBy=multi-user.target
```

### Timer文件
如果需要定时启动执行任务，可以使用Timer文件
必须和service文件同名，比如backup.service,backup.timer
```bash
# /etc/systemd/system/backup.timer
[Unit]
Description=Run backup daily at 2 AM
Requires=backup.service     # 依赖的服务

[Timer]
# 定时方式（可同时使用多种）
OnCalendar=daily               # 每天
OnCalendar=*-*-* 02:00:00      # 每天2点（更精确）
OnBootSec=15min                # 启动后15分钟
OnUnitActiveSec=1h             # 上次激活后1小时

# 时间参数
AccuracySec=1h                 # 精度1小时内执行即可
RandomizedDelaySec=30min       # 随机延迟0-30分钟
Persistent=true                # 错过时间后补执行
Unit=my-backup.service         # 关联的 Service

[Install]
WantedBy=timers.target         # 开机自启
```

# 进程管理
父进程启动的子进程，会在父进程断开后，子进程也会自动关闭。
所以用ssh启动的想长期开启的服务将会在ssh断开后停止。
可以使用screen，tmux，nohup，systemd，docker来守护进程，这样的话启动的服务将不在ssh的bash进程下了。
## 常用进程管理命令
```bash
ps #展示当前用户的进程
ps aux #所有用户的进程
ps auxf #进程树
```
| 信号 | 数字代号 | 命令示例 | 行为 | 适用场景 |
|------|---------|----------|------|----------|
| **SIGTERM** (终止) | **15** (默认) | `kill -15 <PID>` | **优雅终止**，允许进程清理后退出 | **首选方式**，正常关闭进程 |
| **SIGKILL** (强制终止) | **9** | `kill -9 <PID>` | **强制立即终止**，不给清理机会 | 进程卡死、不响应 SIGTERM 时 |
| **SIGINT** (中断) | **2** | `kill -2 <PID>` | 模拟 Ctrl+C，通常优雅终止 | 交互式程序中断 |
| **SIGSTOP** (暂停) | **19** | `kill -19 <PID>` | 暂停进程（可恢复） | 临时挂起进程 |
```bash
kill [信号] <PID>
```

# Crontab
使用Crontab来定时执行任务

## CLI
```bash
# 编辑当前用户的配置
crontab -e

#使用root用户配置
sudo crontab -e

# 列出当前用户的 crontab
crontab -l

# 删除当前用户的 crontab
crontab -r
```
## 配置
进去之后每行一个配置,例如
```text
* * * * * cd /your/work/path && ./script.py >> ./log/script.log 2>&1
   ^               ^                  ^     ^           ^         ^    
时间参数      切换到工作路径           ||   标准输出追加到文件  把标准错误重定向到标准输出
                                  执行的命令     
```
### >> 操作符
```bash
# 标准输出（stdout）追加到文件
command >> file.log
# 效果：每次执行追加内容，不会覆盖旧日志

# 对比 `>`：覆盖写入
command > file.log  # 每次执行覆盖文件
```

### 2>&1 操作符
```bash
# 将标准错误（stderr，文件描述符2）重定向到标准输出（stdout，文件描述符1）
command 2>&1
# 效果：错误信息和正常输出都到同一个地方

# 所以：
command >> file.log 2>&1
# 意思是：标准输出追加到文件，标准错误也重定向到标准输出
```

## 时间格式
### **基本格式：5个星号**
```text
* * * * * 要执行的命令
│ │ │ │ │
│ │ │ │ └─ 星期几 (0-7) 0和7都是周日
│ │ │ └─ 月份 (1-12)
│ │ └─ 日期 (1-31)
│ └─ 小时 (0-23)
└─ 分钟 (0-59)
```
### **每个字段的取值**
`*`代表所有
- 分钟：0-59
- 小时：0-23  
- 日期：1-31
- 月份：1-12
- 星期：0-7（0和7都是周日，1=周一，6=周六）

### **特殊符号解释**

#### **1. 逗号 `,`（多个时间点）**
```bash
# 每天3点和15点执行
0 3,15 * * * command.sh

# 每周一、三、五的10点30分
30 10 * * 1,3,5 command.sh
```

#### **2. 连字符 `-`（时间范围）**
```bash
# 工作日上午9点到下午5点，每小时执行
0 9-17 * * 1-5 command.sh

# 每月1-10号的凌晨2点
0 2 1-10 * * command.sh
```

#### **3. 斜杠 `/`（间隔时间）**
```bash
# 每5分钟执行一次
*/5 * * * * command.sh
# 等价于：0,5,10,15,20,25,30,35,40,45,50,55

# 每3小时的0分钟执行
0 */3 * * * command.sh
# 等价于：0 0,3,6,9,12,15,18,21 * * *

# 每2天的中午12点
0 12 */2 * * command.sh
```

### **示例**
- * * * * * ：每分钟执行一次
- 0 * * * * ：每小时的第0分钟执行一次
- 0 1 * * * ：每天的1点整执行一次
- 0 1 2 * * ：每月2号的1点整执行一次
- 0 1 2 3 * ：每年的3月2号的1点整执行一次
- 0 1 2 3 4 ：每年的3月2号和每年3月的每个星期4的1点整执行一次
- */30 9-17 * * 1-5 ：周一到周五的9-17点，每30分钟执行一次
- 0 10,14 1,15 * * ： 每月1号和15号的上午10点、下午2点
[https://crontab.guru/](https://crontab.guru/)这个网站可以进行crontab验证

## 系统crontab
```bash
# 系统级 crontab 文件位置
/etc/crontab
# 格式包含用户字段：* * * * * username command

# 系统 cron 目录
/etc/cron.d/           # 自定义 cron 文件
/etc/cron.daily/       # 每天执行
/etc/cron.hourly/      # 每小时执行
/etc/cron.weekly/      # 每周执行
/etc/cron.monthly/     # 每月执行
```
配置和用户crontab有点区别
```text
* * * * * root /path/to/command
0 2 * * * www-data /path/to/backup.sh
```
需要指定用户字段，确定用谁的权限来执行任务

# 实用工具
## wget
命令行下载工具
```bash
wget [选项] [URL]
```
| 常用选项 | 说明 |
|---------|------|
| -O filename | 指定文件名 |
| -c          | 断点续传   |
| -b         |  后台下载   |
## tar
常用的归档工具
```bash
tar [选项] [文件或目录]
```
选项太多了，只记常用的就行
```bash
# 1. 创建压缩包
tar -czf 文件名.tar.gz 要压缩的目录/

# 2. 解压（万能）
tar -xf 压缩包文件名

# 3. 查看内容
tar -tf 压缩包文件名
```
## ip
选项功能也很多，只记常用的
```bash
ip a    # 查看所有网络接口 (address)
ip r    # 查看路由表 (route)  
ip l    # 查看链路状态 (link)
```