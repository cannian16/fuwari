---
title: git备忘
published: 2025-10-16
description: '学了好几遍了，今天记一下'
image: ''
tags: [git]
category: '备忘'
draft: false 
lang: ''
---

**官网**:https://git-scm.com/
# git代理
## HTTP代理
```bash
#端口不定看你设置
git config --global http.proxy "http://127.0.0.1:<7890>"
git config --global https.proxy "http://127.0.0.1:<7890>"

git config --global http.proxy "socks5://127.0.0.1:<1080>"
git config --global https.proxy "socks5://127.0.0.1:<1080>"
#取消设置
git config --global --unset http.proxy
git config --global --unset https.proxy
```
## SSH代理
改 ~/.ssh/config 文件（不存在则新建）
```
Host github.com
   HostName github.com
   User git
   # 走 HTTP 代理
   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080
   # 走 socks5 代理（如小飞机 or V2xxx）
   # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p
```
# git使用
git工作流程
```
工作区 (修改文件) 
    → git add → 
暂存区 (准备提交) 
    → git commit → 
版本库 (永久保存)
```
## 基本命令
```bash
#git初始化，在当前文件中添加一个.git目录，里面存着所有与git有关的东西
#如果fork过来的项目不让你设置成私有仓库可以考虑把这个目录删了然后再重新git init
git init

#查看git的状态
git status

#添加某个或者某个路径下的所有文件到暂存区
git add <path>

#提交至版本库
git commit [-m] ["description"]

#回退版本默认是mixed模式，工作区保留，暂存区不保留
git reset HEAD^
# 从暂存区移除filename.txt,工作区保留
git reset filename.txt  

#查看暂存区和工作区的不同
git diff
#比较工作区和版本库的区别
git diff HEAD^
#比较暂存区和版本库的区别
git diff --cached
#比较两个版本之间的区别
git diff <版本1的id> <版本2的id>

# 查看提交历史
git log
# 查看简洁版的提交历史
git log --oneline

#查看当前版本库中的所有文件
git ls-files

#删除path对应的文件从工作区，并把这个改动添加至暂存区
git rm <path>

#用http的方式的话要输用户名密码，但密码是GitHub的Personal access tokens
git push [origin] [分支名]

git pull
```
## git分支控制
### 创建分支
```bash
# 创建分支
git branch feature/new-feature

# 切换到新分支
git checkout feature/new-feature

# 或者使用 switch
git switch feature/new-feature
```
### 查看分支
```bash
# 查看本地分支（当前分支前会有 * 标记）
git branch

# 查看所有分支（包括远程）
git branch -a

# 查看分支及其最近提交
git branch -v
```
### 合并分支
#### 方式一：快速合并（Fast-forward Merge）
适用于要合并的分支是当前分支的直接下游：
```bash
# 1. 切换到要合并的目标分支（通常是主分支）
git checkout main

# 2. 确保工作目录是干净的
git status

# 3. 合并分支
git merge feature/new-feature

# 4. 删除已合并的分支（可选）
git branch -d feature/new-feature
```

#### 方式二：普通合并（创建合并提交）
```bash
# 禁用快速合并，总是创建合并提交
git merge --no-ff feature/new-feature
```

#### 方式三：压缩合并（Squash Merge）
```bash
# 将分支的所有提交压缩成一个提交再合并
git merge --squash feature/new-feature
git commit -m "合并 feature/new-feature 的功能"
```
### 解决合并冲突

当合并时出现冲突：
```bash
# 1. 查看冲突文件
git status

# 2. 打开冲突文件，手动解决冲突
# 冲突标记示例：
<<<<<<< HEAD
当前分支的内容
=======
要合并的分支的内容
>>>>>>> feature/new-feature

# 3. 标记冲突已解决
git add 文件名

# 4. 完成合并
git commit
```
### 完整的工作流程：
```bash
# 1. 基于主分支创建功能分支
git checkout main
git pull origin main
git checkout -b feature/user-authentication

# 2. 在新分支上开发
git add .
git commit -m "添加用户登录功能"

# 3. 切换回主分支并拉取最新代码
git checkout main
git pull origin main

# 4. 合并功能分支
git merge feature/user-authentication

# 5. 推送合并后的代码
git push origin main

# 6. 删除本地功能分支
git branch -d feature/user-authentication

# 7. 删除远程功能分支（如果存在）
git push origin --delete feature/user-authentication
```

## .gitignore
直接就把路径一行行写进去就行#是注释比如:
```
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/
```


# git的其他小知识
问AI的
## HEAD

### 基本概念

#### HEAD
- **当前所在的分支的最新提交**
- 是一个指针，指向你当前的工作位置
- 可以理解为"你正在哪里工作"

```bash
# 查看HEAD指向的提交
git show HEAD
cat .git/HEAD
```

### 区别对比

#### HEAD^ (插入符)
- **指向父提交**
- 主要用于合并提交的场景

```bash
HEAD^    # 第一个父提交
HEAD^2   # 第二个父提交（合并提交时）
```

#### HEAD~ (波浪符)
- **向上回溯指定代数的提交**
- 主要用于线性历史

```bash
HEAD~    # 向上回溯1代（等同于HEAD^）
HEAD~2   # 向上回溯2代
HEAD~3   # 向上回溯3代
```

### 实际示例

假设提交历史如下：
```
A - B - C - D (HEAD)
```

```bash
HEAD    # 指向提交 D
HEAD^   # 指向提交 C (D的父提交)
HEAD~   # 指向提交 C (等同于HEAD^)
HEAD~2  # 指向提交 B
HEAD~3  # 指向提交 A
```

### 合并提交的特殊情况

对于合并提交：
```
    B - C (feature)
   /      \
A - D - E - M (HEAD, 合并提交)
```

```bash
HEAD    # 指向合并提交 M
HEAD^   # 指向 E (第一个父提交)
HEAD^2  # 指向 C (第二个父提交)
HEAD~   # 指向 E (等同于HEAD^)
HEAD~2  # 指向 D
```

### 常用命令示例

```bash
# 查看上一个提交
git show HEAD^
git show HEAD~

# 查看上上个提交
git show HEAD^^
git show HEAD~2

# 重置到上一个提交（保留工作区）
git reset HEAD^

# 重置到上上个提交（保留工作区）
git reset HEAD~2

# 比较当前与上一个提交的差异
git diff HEAD^ HEAD
```

### 记忆技巧
- **`^`** - 像分支一样"分叉"，用于处理多个父提交
- **`~`** - 像直线一样"回溯"，用于线性历史
- **数字** - `^`后面的数字表示第几个父提交，`~`后面的数字表示回溯几代

### 等价关系
```bash
HEAD     = HEAD~0
HEAD^    = HEAD~1
HEAD^^   = HEAD~2
HEAD^^^  = HEAD~3
HEAD^2   # 没有等价的~表示法（特殊场景）
```


# 教学视频
<iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1HM411377j&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
